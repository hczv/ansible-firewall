#
# Recommended minimum configuration:
#

# Example rule allowing access from your local networks.
# Adapt to your needs.
acl localnet src 10.0.0.0/8     # RFC 1918 A (private networks)
acl localnet src 172.16.0.0/12  # RFC 1918 B (private networks)
acl localnet src 192.168.0.0/16 # RFC 1918 C (private networks)
acl localnet src fc00::/7       # RFC 4193 local private network range
acl localnet src fe80::/10      # RFC 4291 link-local (directly plugged) machines

acl SSL_ports port 443
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
acl Safe_ports port 443         # https
acl Safe_ports port 70          # gopher
acl Safe_ports port 210         # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280         # http-mgmt
acl Safe_ports port 488         # gss-http
acl Safe_ports port 591         # filemaker
acl Safe_ports port 777         # multiling http

acl CONNECT method CONNECT

#
# Recommended minimum Access Permission configuration:
#
# Deny requests to certain unsafe ports
http_access deny !Safe_ports

# Deny CONNECT to other than SSL ports
http_access deny CONNECT !SSL_ports

# Only allow cachemgr access from localhost
http_access allow localhost manager
http_access deny manager

# We strongly recommend to not allow access to your cache from people outside your local network!
#
# Example rule allowing your local "internal" networks, but denying all others access
http_access allow localnet
http_access allow localhost

# And finally deny all other access to this proxy


# Squid normally listens to port 3128
http_port {{ squid_port }}

# Leave coredumps in the first cache dir
coredump_dir {{ squid_cache_dir }}

# Add authentication (htpasswd mode)
{% if squid_auth_mode == 'htpasswd' and ((squid_users | default([])) | length > 0 or (squid_auth_users | default([])) | length > 0) %}
auth_param basic program {{ squid_basic_ncsa_auth_path }} {{ squid_passwd_path }}
auth_param basic children 5 startup=5 idle=1
auth_param basic realm Squid proxy-caching web server
auth_param basic credentialsttl 2 hours
acl authenticated proxy_auth REQUIRED
http_access allow authenticated
{% endif %}

{# Named domain whitelist lists (new style) #}
{% for wl in (squid_whitelist_domains | default([])) %}
acl {{ wl.name }}_dstdomain dstdomain "{{ wl.domains | join(' ') }}"
acl {{ wl.name }}_servername ssl::server_name "{{ wl.domains | join(' ') }}"
{% endfor %}

{# Per-user non-SSL whitelists: support new `squid_users` (or legacy `squid_auth_users`) #}
{% for user in (squid_users | default(squid_auth_users | default([]))) %}
	{# legacy per-user non-ssl list (explicit domains) #}
	{% if user.non_ssl_whitelist is defined and user.non_ssl_whitelist | length > 0 %}
acl {{ user.username }}_non_ssl_whitelist dstdomain "{{ user.non_ssl_whitelist | join(' ') }}"
http_access allow {{ user.username }}_non_ssl_whitelist authenticated
	{% endif %}
	{# new-style per-user named whitelists (references to squid_whitelist_domains) #}
	{% if user.whitelists is defined and user.whitelists | length > 0 %}
		{% for wlname in user.whitelists %}
http_access allow {{ wlname }}_dstdomain authenticated
		{% endfor %}
	{% endif %}
{% endfor %}

{# IP-based auth: allow IPs and their referenced whitelist lists #}
{% if squid_auth_mode == 'ip' %}
	{% if squid_ip_allowed is defined and squid_ip_allowed | length > 0 %}
acl ip_allowed src {{ squid_ip_allowed | join(' ') }}
http_access allow ip_allowed
	{% endif %}
	{% for ipset in (squid_ips | default([])) %}
		{% set idx = loop.index0 %}
acl ip_entry_{{ idx }} src {{ ipset.ips | join(' ') }}
		{% if ipset.whitelists is defined and ipset.whitelists | length > 0 %}
			{% for wlname in ipset.whitelists %}
http_access allow {{ wlname }}_dstdomain ip_entry_{{ idx }}
			{% endfor %}
		{% endif %}
	{% endfor %}
{% endif %}

# Add domain-based access control
{% for acl in squid_acl_domains %}
acl {{ acl.name }} dstdomain "{{ acl.domains | join(' ') }}"
{% if squid_auth_mode == 'htpasswd' %}
http_access allow {{ acl.name }} authenticated
{% else %}
http_access allow {{ acl.name }}
{% endif %}
{% endfor %}

# SSL Bumping
{% if squid_ssl_bump_enabled %}
http_port {{ squid_port }} ssl-bump cert={{ squid_ssl_bump_cert_path }} key={{ squid_ssl_bump_key_path }} generate-host-certificates=on dynamic_cert_mem_cache_size=4MB
always_direct allow all
ssl_bump stare all
ssl_bump bump all
sslproxy_cert_error allow all
sslproxy_flags DONT_VERIFY_PEER
acl SslBumpCertError ssl_error SQUID_X509_V_ERR_DOMAIN_MISMATCH
http_access allow SslBumpCertError
acl step1 at_step SslBump1
acl step2 at_step SslBump2
acl step3 at_step SslBump3

# Whitelisting for SSL Bumping
{# Splice (do not bump) for named whitelist domain lists when SSL bumping is enabled.
	 We declare server_name ACLs above and splice them here. This mirrors prior behavior
	 where per-user whitelist ACLs were used (they were global in effect).
 #}
{% if (squid_whitelist_domains | default([])) | length > 0 %}
	{% for wl in (squid_whitelist_domains | default([])) %}
ssl_bump splice {{ wl.name }}_servername
	{% endfor %}
{% endif %}


ssl_bump peek step1
ssl_bump bump step2
ssl_bump splice step3
{% endif %}

# Final default deny â€” placed after all allow rules
http_access deny all

# We recommend to use the following parameters for a first good experience:
#
# cache_mem 256 MB
# maximum_object_size 4 MB
# maximum_object_size_in_memory 512 KB
#
# cache_dir ufs /var/spool/squid 10000 16 256
#
# For more details, see the Squid configuration file documentation.
#
cache_dir ufs {{ squid_cache_dir }} {{ squid_cache_size }} 16 256
maximum_object_size {{ squid_max_object_size }}
maximum_object_size_in_memory {{ squid_max_object_size_in_memory }}
